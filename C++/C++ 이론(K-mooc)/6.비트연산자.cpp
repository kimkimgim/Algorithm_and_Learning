// 전처리기
// # 이라고 구문으로 작성한 전처리기는 모든 컴파일 과정 중에서 제일 먼저 수행됨

// define -> 치환한다라는 뜻
// 1. 가독성
// 2. 유지보수

// #define HUNGRY 1
// #define THIRSTY 2
// #define TIRED 4     // 3번째 칸에 들어가야하기 때문에 4로
// #define FIRE 8 
// #define COLD 16    // ... 이렇게 쭉 나열하기 힘들기 때문에 보통 16진수를 씀


#define HUNGRY 0x001
#define THIRSTY 0x002
#define TIRED  0x004
#define FIRE   0x008

#define COLD   0x10      //  16자리에서는 (16에서 다음자리로 넘어가니까) 10이 나옴
#define POISON 0x20      //  32는 16의 2묶음이기때문에 20
#define POISON 0x40 
#define POISON 0x80 

#define POISON 0x100     // 반복
#define POISON 0x200 
#define POISON 0x400
#define POISON 0x800



int main()
{
  // 비트연산자
  // 비트단위로 연산될 때 시행되는 것
  
  // 1. 비트 쉬프트 <<, >>
  unsigned char byte = 1;

  byte <<= 1;  
  // 2^n 배수
  // [0][0][0][0][0][0][0][1] -> [0][0][0][0][0][0][1][0]

  // [1][0][1][0] 을 한칸 밀면 [1][0][1][0][0]
  //   10           ->        20             => 2배가 된 것
  // 그래서 2칸 밀면 2에 2승 증가
  //      3칸 밀면 2에 3승이 증가하는 것

  byte >>= 1;
  // 2^n 나눈 몫
  // 반대로 밀면 2의 -1승만큼 줄어들음
  // 비트가 움직이기 때문에 나머지가 없음
  // 비트가 홀수라는건 마지막 [1] 이라는 건데, >> 반대로 밀어버리는 것이기 때문에
  // ...[0] 으로 1이 소실 되어서 결국 나머지는 없고 몫만 남음


  // 2. 비트 곱(&), 합(|), xor(^), 반전(~)
  
  // 비트단위의 연산은 비트단위 기준으로 연산하는 것 

  // 비트 곱(&)
  // [1][1][0][0][0][1][0][1]
  // [0][1][0][0][0][1][1][1]
  // =========================
  // [0][1][0][0][0][1][0][1]

  // 둘 다 1이면 1
  // 둘 중 하나라도 0이면 0 

  // 비트 합(|)
  // 둘 중 하나라도 1이면 1이 나옴

  // 비트 반전(~)
  // 1을 0으로, 0을 1으로 반전
 

  // ⭐️⭐️⭐️ xor 
  // 두자리의 비트가 같으면 0
  //             다르면 1


  // 언제 비트마스크를 사용하나?

  int iStart = HUNGRY;
  // 위에서 우린 HUNGRY를 1로 지정했기에 위에 iStart = 1 이 됨.

  // int 는 32비트(4바이트, 표현할 수 있는 조합의 수는 2^32)
  // ''' [][][][][][][][][][][] ''' 
  // 각각의 칸을 상태라고 하면 
  // 첫번째 칸을 배고픈지 안배고픈지 
  // 배고프면 ''' [][][][][][][][][][][1] ''' 
  // 안배고프면 ''' [][][][][][][][][][][0] ''' 
  // 32개의 상태를 나타낼 수 있고 이를 조합할 수 있음


  // 그럼 각 칸을 아래와 같이 나타낼 수 있음
  // #define HUNGRY 1     // 첫번째 칸
  // #define THIRSTY 2    // 두번째 칸
  // #define TIRED 4      // 3번째 칸에 들어가야하기 때문에 4로 넣어야 함


  // 비트 넣기
  unsigned int iStatus = 0;
  iStatus |= HUNGRY;
  iStatus |= THIRSTY;
  // '|=' : 비트단위의 합친 결과를 넣겠다.(iStatus 와 HUNGRY 비트단위로 합친결과를 iStatus에 넣겠다.  )

  // 아래처럼 상태를 넣어놓고 상태에 대해서만
  // 예를들어 캐릭터의 상태가 있는데 배고픈지만 궁금하면
  // hungry 자리만 아래와 같이 확인할 수 있음 
  // [1][1][0][1]
  // [0][0][0][1]
  // ============
  // [0][0][0][1]    -> 첫번째 자리만 1이 되기때문

  // 상태확인 
  if(iStatus & HUNGRY)
  {

  }


  // 비트 빼기
  // [1][1][0][1]
  // [0][1][0][0]
  // 위의 경우 3번째 자리를 빼주고 싶을때 어떻게 해야하나?
  // 비교연산 + 그런상태에 있을경우에만 xor 로 빼야함
  
  //  ⭐️⭐️⭐️  보통은 아래와 같이함 (위처럼 할 수 있긴 함), 아래 구문 그냥 외우기!!!! 
  iStatus &= ~THIRSTY;
  // 두번째 자리를 빼고싶을 때
  // [1][0][1][0]   // 원래 상태
  // [0][0][1][0]  -> 비트 반전 : [1][1][0][1]
  // ------------

  // [1][0][1][0]
  // [1][1][0][1]
  // =============
  // [1][0][0][0]  -> 원래상태를 건드리지 않고 뺄 수 있음


  // 게임뿐만 아니라 전달받아야할 수행이 많을 때 많이 사용 
  return 0;
}


// define 코드를 작성하는 이유는? 
  // [1][1][0][1]
  // [0][1][0][0]
  // 위의 경우 3번째 자리를 빼주고 싶을때 어떻게 해야하나?

