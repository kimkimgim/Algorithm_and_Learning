int main()
{
  // 정수형 : char(1), short(2)(2bite=16bit), int(4)(4bite), long(4), long long(8)
  // 실수형 : float(4), double(8)
  
  // 1 바이트 양수만 표현
  // 256가지 -> 0 ~ 255
  unsigned char c = 0;
  c = 0;
  c = 255;

  // 1바이트로 양수, 음수 둘 다 표현
  // -128 ~ 0 ~ 127
  char c1 = 0;
  c1 = -1;


  // 위 처럼 되는 이유는 
  // [0][][][][][][][]  0 일때 양수로 보고 나머지 7칸 2^7 = 127 가지 
  // [1][][][][][][][]  1 일때 음수로 보고 나머지 7칸 2^7 = 127 가지
  // 그래서 0일떄 양수 0 ~ 127 까지, 1일때 음수로보고 -1 ~ -128까지 보는것
  // 그래서 0 과 1 을 나타내는 곳을 msb 라고 표현: 가장 중요한 비트(most sgnificant bit) 라는 표현(왜? 음수 양수를 표현하니까)
  
  // [0][0][0][0][0][0][0][1] -> + 1 (0)  
  // [1][0][0][0][0][0][0][1] -> -1 (x-> 음수는 양수처럼 단순하게 표현되지 않음) ⭐️⭐️⭐️
  
  // 컴퓨터는 덧셈처럼 더한다!가 아니라 음수를 더한다는 개념으로 접근함
  // 음수는 10 + (-10) = 0 으로 봄 -> 10이랑 더해서 0이 나오는 수를 음수로 본다. 그럼 여기선 -10을 음수로 봄

  // [0][1][1][1][1][1][1][1]   => 127
  // [1][0][0][0][0][0][0][1]   ==> ?
  // ---------------------------------
  //                                0
  // 127에 어떤 수를 더해서 0이 되는 수를 찾는 것이 음수의 방법 
  // 즉 ? 는 -127이 된다.
  // unsigned 일경우 [1][0][0][0][0][0][0][1] == 129 그러나 signed 일경우 [1][0][0][0][0][0][0][1] == -127이 된다.


  // 양수만 있을때 8칸이 다 1로 채워져있는 것([1][1][1][1][1][1][1][1])은 양수라 볼까? 음수라 볼까?
  // 양수만 unsigned 일 경우는 8칸이 다 1로 채워져 있는 것을 255로 보지만
  // 양수 음수 둘다 있을때는 앞에수를 1이 - 를 의미하므로 8칸이 다 1로 채워져 있는 것은 -1로 본다.
  // 그래서 만양 양수,음수 둘다 범위(signed)에서 c1=255([1][1][1][1][1][1][1][1])는 컴퓨터는 -1로 인식한다.
  // [1][1][1][1][1][1][1][1] 에서 맨 앞의 수때문에 음수라는 것을 확인
  // [1][1][1][1][1][1][1][1] + ? = 0 이되어야하는데
  // [1][1][1][1][1][1][1][1] + [0][0][0][0][0][0][0][1] = 0
  //                          + 1                        = 0
  // 결국 [1][1][1][1][1][1][1][1] = -1 임을 알 수 있음(컴퓨터는 -1로 인식)
  // => ⭐️⭐️⭐️ 둘 다 동일한 메모리 크기(동일한 값, 데이터)를 가졌지만 어떻게 해석하느냐에 따라 다름 -> 포인터랑 연관


  // 만약 위에서 나는 양수를 선언했는데 c = -1 을 하면? 
  // -1 + ? = 0 
  // ? == 1 -> [0][0][0][0][0][0][0][1] 이렇게 표현되고
  // a + [0][0][0][0][0][0][0][1] = 0 이 되면 된다.
  // a = [1][1][1][1][1][1][1][1]
  // 즉 양수로만 표현하기에 [1][1][1][1][1][1][1][1] = 255
  // => 컴퓨터는 255로 인식함


  // ⭐️⭐️⭐️ 음의 정수 찾기(2의 보수법)을 찾기
  // 대응되는 양수의 부호를 반전 후, 1을 더하면 된다.
  // [0][0][0][0][0][0][1][0]  == 2
  // [1][1][1][1][1][1][0][1] + 1 = [1][1][1][1][1][1][1][0]

  // [0][0][0][0][0][0][1][0]
  // [1][1][1][1][1][1][1][0]
  // ------------------------
  // [0][0][0][0][0][0][0][0]   
  // 이렇게 된다.           
  
  
  // 만약 내가 변수 공간을 int자료형으로 설정을 했을 때,
  // 4바이트는 32이니까 signed이니까 약 42억 메모리 개수가 됨
  // 게임에서 데미지를 받으면 2배 3배 능력치가 된다고 하면 메모리를 넘어가면 음수가 되어서 갑자기 몬스터가 죽어버림.
  // 자리수를 넘어가버린것이니까 위에 내용을 고려해야함! 

return 0;
}


// Q1. [1][0][0][0][0][0][0][1] 는 [0][0][0][0][0][0][0][1]의 음수인가? 
// Q2. [0][0][0][0][0][0][0][1] 에 어떤 칸의 수를 1로 바꿔야지 음수로 보는가?
// Q3. [1][1][1][1][1][1][1][1] 이 usigned 일 경우와 아닌 경우에 각각 컴퓨터는 어떻게 인식하나?
// Q4. c = -1 을 넣고 c1 = 255를 넣었을 경우 컴퓨터는 어떻게 인식하나?