int main(){

  // 정수와 실수 데이터를 처리하는 방식이 다르기 때문에
  // 정수는 비트라는 한정적인 공간 안에서 이진수로 값을 채워가는 것 => 표현할 수 있는 경우의 숫자는 한정적
  // 실수는 0 과 1 사이에 무수하게 많은 수를 표현할 수 있음
  
  // 부동소수점()
  // 21.8125 를 이진수로 나타내면
  // (21)10=(10101)2
  // (0.8125)10=(0.1101)2   
  // 소수점 아래가 위와같이 표현되는 이유는 소수점 아래 2개가 모여야 1이 되는데 
  // 그러면 첫번째자리 1 => 0.5 , 두번째 자리는 그보다 작은 0.25(두번째자리가 2개 모이면 1이 되어서 그 다음 자리수로 넘어가기 때문)
  // 마지막 1은 0.0625 
  // 0.5+ 0.25 + 0.0625 => 0.8125가 되기 때문
  // 즉 (21.8125)10=(10101.1101)2
  // 위와 같이 소수점을 나타내는 방식을 0과1로 이진법을 추가해가면서 근사한 값을 나타낼 수 는 있지만 정확한 값은 만들지 못함

  // ⭐️⭐️⭐️ 그렇기 때문에 실수의 정밀도를 정확하게 파악하지 않으면 
  // 예) 실수 if 1 이상 조건을 걸었는데, 0.999999 가 걸리지 않아 문제가 될 수 있음! 

  // => 부동소수점이 중요한게 아니라 정수랑 실수는 표현하는 법이 다르다는 것을 이해해야함!
  // 정수 4 와 실수 4.0 은 완전히 표현방식이 다른것
  

  int a = 4 + 4.0;
  // => 여기서 a를 정수 선언했기에 4.0을 정수표현방식으로 바꾸어 계산을 한것임 
  // => ⭐️⭐️⭐️ 결국 우리가 생각하는 코드 과정이 불필요하게 늘어남!

  // 실수형 : float(4), double(8)
  // 실수형은 근사값으로 표현! 세상 모두의 실수를 정확하게 나타낼 수 없기 때문!


  // ⭐️⭐️⭐️ 정수표현 방식과 실수 표현 방식은 다르다.
  // 실수 표현방식은 정밀도에 의존한다.
  // 따라서 double(8) 자료형이 float(4)보다 더 아래의 소수점까지 정확하게 표현이 가능하다.

  // 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.
  
  float f = 10.2415f + (float)20; 
  // 위처럼 적지 않아도 f 가 실수이기 때문에 20을 실수로 변하긴함.
  // 그래도 명시적으로 명확하게 변환해주는 것이 좋음 
}

